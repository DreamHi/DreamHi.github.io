---
layout: post
title: 软件测试分类
categories: test
catalog: true
original: true
tags: 测试 分类
---

Grenford J. Myers在《The Art of Software Testing》一书中的观点
* 软件测试是为了发现错误而执行程序的过程
* 测试是为了证明程序有错，而不是证明程序无错误
* 一个好的测试用例是在于它能发现至今未发现的错误
* 一个成功的测试是发现了至今未发现的错误的测试

## 测试原则

- 应当把“尽早地和不断地进行软件测试”作为软件开发者的座右铭。  
> 不应把软件测试仅仅看作是软件开发的一个独立阶段，而应当把它贯穿到软件开发的各个阶段中。坚持在软件开发的各个阶段的技术评审，这样才能在开发过程中尽早发现和预防错误，把出现的错误克服在早期，杜绝某些发生错误的隐患。
- 测试用例应由测试输入数据和与之对应的预期输出结果这两部分组成。  
> 测试以前应当根据测试的要求选择测试用例(Test case)，用来检验程序员编制的程序，因此不但需要测试的输入数据，而且需要针对这些输入数据的预期输出结果。
- 程序员应避免检查自己的程序。  
> 程序员应尽可能避免测试自己编写的程序，程序开发小组也应尽可能避免测试本小组开发的程序。如果条件允许，最好建立独立的软件测试小组或测试机构。这点不能与程序的调试(debuging)相混淆。调试由程序员自己来做可能更有效。
- 在设计测试用例时，应当包括合理的输入条件和不合理的输入条件。  
> 合理的输入条件是指能验证程序正确的输入条件，不合理的输入条件是指异常的，临界的，可能引起问题异变的输入条件。软件系统处理非法命令的能力必须在测试时受到检验。用不合理的输入条件测试程序时，往往比用合理的输入条件进行测试能发现更多的错误。
- 充分注意测试中的群集现象。  
> 在被测程序段中，若发现错误数目多，则残存错误数目也比较多。这种错误群集性现象，已为许多程序的测试实践所证实。根据这个规律，应当对错误群集的程序段进行重点测试，以提高测试投资的效益。
- 严格执行测试计划，排除测试的随意性。
> 测试之前应仔细考虑测试的项目，对每一项测试做出周密的计划，包括被测程序的功能、输入和输出、测试内容、进度安排、资源要求、测试用例的选择、测试的控制方式和过程等，还要包括系统的组装方式、跟踪规程、调试规程，回归测试的规定，以及评价标准等。对于测试计划，要明确规定，不要随意解释。
- 应当对每一个测试结果做全面检查。
> 有些错误的征兆在输出实测结果时已经明显地出现了，但是如果不仔细地全面地检查测试结果，就会使这些错误被遗漏掉。所以必须对预期的输出结果明确定义，对实测的结果仔细分析检查，抓住征侯，暴露错误。
- 妥善保存测试计划，测试用例，出错统计和最终分析报告，为维护提供方便。

## 软件测试阶段

### 单体测试(Unit testing)
单体测试是对软件中的基本组成单位进行测试。目的是检验软件基本组成单位的正确性。
指一段代码的基本测试，其实际大小是未定的，通常是一个函数或子程序，一般由开发者执行。

### 集成测试(Integration testing)
集成测试是在软件系统集成过程中所进行的测试。目的是检查软件单位之间的接口是否正确。
被测试系统的所有组件都集成在一起，找出被测试系统组件之间关系和接口中的错误。该测试一般在单元测试之后进行。

### 系统测试(System testing)
系统测试是对已经集成好的软件系统进行彻底的测试，以验证软件系统的正确性和性能等是否满足其规约所指定的要求。

### 验收测试(Acceptance testing)
验收测试是部署软件之前的最后一个测试操作。验收测试的目的是确保软件准备就绪，向软件购买都展示该软件系统满足其用户的需求。

### Alpha测试(Alpha testing)
是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由程序员和测试员完成。
Alpha测试可以从软件产品编码结束之后开始，或在模块（子系统）测试完成后开始，也可以在确认测试过程中产品达到一定的稳定和可靠程度之后再开始。

### Beta测试(Beta testing)
是软件的多个用户在一个或多个用户的实际使用环境下进行的测试，开发者通常不在测试现场，Beta测试也不能由程序员或测试员完成。
因而，Beta测试是在开发者无法受控的环境下进行的软件现场应用。Beta测试着重于产品的支持性，只有当Alpha测试达到一定的可靠程度后才能开始Beta测试。

### 回归测试(Regression Testing)
一般出现在维护阶段。在发生修改之后重新测试先前的测试以保证修改的正确性。
理论上，对软件的任何新版本，都需要进行回归测试，验证以前发现和修复的错误 是否在新软件版本上再现。

## 测试分类

| 测试类型       | 说明                                       |
|--------------| ----------------------------------------- |
| 单元测试 | 最小函数、模块、类的测试。已知程序的内部逻辑，覆盖全部代码的测试 |
| 功能测试 | 黑盒类测试，测试软件同功能需求的适合度 |
| 负载测试 | 测试应用程序在重负载下的承受能力 |
| 压力测试 | 修复或调整好软件环境之后重新测试 |
| 性能测试 | 测试应用程序在重负载下的性能 |
| 安全性测试 | 对系统存在的安全隐患或者漏洞进行测试   |
| 兼容性测试  | 特定的硬件平台上，不同的应用软件不同，不同的操作系统平台上，在不同的网络等环境中能正常的运行的测试。 |
| 安装/卸载测试 | 测试软件安装、卸载过程 |
| 易用性测试| 易用性测试是指用户使用软件时是否感觉方便，比如是否最多点击鼠标三次就可以达到用户的目的。|

## 测试方法

| 测试方法       | 说明                                       |
|--------------| ----------------------------------------- |
| 白盒测试 | 又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。　 |
|　　基本路径法 | 在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。　 |
|　　语句覆盖 | 语句覆盖每条语句至少执行一次。　 |
|　　分支覆盖 | 每个判定的每个分支至少执行一次。　 |
|　　条件覆盖 | 每个判定的每个条件应取到各种可能的值。　 |
|　　组合覆盖 | 每个判定中各条件的每一种组合至少出现一次。　 |
|　　形式化方法（UML SPIN） | 渗透在软件生命周期的各个环节的数学方法或者具有严格数学基础的软件开发方法.　 |
| 黑盒测试 | 也称功能测试，它是通过测试来检测每个功能是否都能正常使用。　 |
|　　等价类划分 | 把所有可能的输入数据,划分成若干子集,然后从子集中选取少量具有代表性的数据作为测试数据　 |
|　　边界值分析 | 大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。　 |
|　　因果图 | 是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。　 |
|　　决策表 | 也称判定表,是分析和表达多逻辑条件下执行不同操作的工具.　 |
|　　状态转化法 | 用于表示输入数据序列以及相应的输出数据;由输入数据和当前状态决定输出数据和后续状态.　 |
|　　正交试验方法 | 从大量的实验数据中挑选适量的、有代表性的点，合理安排测试的设计方法。　 |
|　　错误猜测法 | 基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法.　 |
|　　模糊测试法 | 是一种通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法。　 |
| 探索性测试 | |
